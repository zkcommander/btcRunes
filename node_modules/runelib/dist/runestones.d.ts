/// <reference types="node" />
import { Transaction } from "bitcoinjs-lib";
import { Option } from "./fts";
/**
 * Rune IDs are represented in text as BLOCK:TX.
 */
export declare class RuneId {
    block: number;
    idx: number;
    constructor(block: number, idx: number);
    next(block: bigint, idx: bigint): Option<RuneId>;
}
/**
 * Rune ID block heights and transaction indices in edicts are delta encoded.
 * Edict rune ID decoding starts with a base block height and transaction index of zero.
 * When decoding each rune ID, first the encoded block height delta is added to the base block height.
 * If the block height delta is zero, the next integer is a transaction index delta.
 * If the block height delta is greater than zero, the next integer is instead an absolute transaction index.
 */
export declare class Edict {
    id: RuneId;
    amount: bigint;
    output: number;
    constructor(id: RuneId, amount: bigint, output: number);
    static from_integers(tx: Transaction, id: RuneId, amount: bigint, output: bigint): Option<Edict>;
}
export declare enum Flag {
    /** The Etching flag marks this transaction as containing an etching. */
    Etching = 0,
    /** The Terms flag marks this transaction's etching as having open mint terms. */
    Terms = 1,
    /** The Turbo flag marks this transaction's etching as opting into future protocol changes. These protocol changes may increase light client validation costs, or just be highly degenerate. */
    Turbo = 2,
    /** The Cenotaph flag is unrecognized. */
    Cenotaph = 127
}
export declare enum Tag {
    /** The Body tag marks the end of the runestone's fields, causing all following integers to be interpreted as edicts. */
    Body = 0,
    /** The Flag field contains a bitmap of flags, whose position is 1 << FLAG_VALUE: */
    Flags = 2,
    /** The Rune field contains the name of the rune being etched. If the Etching flag is set but the Rune field is omitted, a reserved rune name is allocated. */
    Rune = 4,
    /** The Premine field contains the amount of premined runes. */
    Premine = 6,
    /** The Cap field contains the allowed number of mints. */
    Cap = 8,
    /** The Amount field contains the amount of runes each mint transaction receives. */
    Amount = 10,
    /** The HeightStart and HeightEnd fields contain the mint's starting and ending absolute block heights, respectively. The mint is open starting in the block with height HeightStart, and closes in the block with height HeightEnd. */
    HeightStart = 12,
    HeightEnd = 14,
    /** The OffsetStart and OffsetEnd fields contain the mint's starting and ending block heights, relative to the block in which the etching is mined. The mint is open starting in the block with height OffsetStart + ETCHING_HEIGHT, and closes in the block with height OffsetEnd + ETCHING_HEIGHT. */
    OffsetStart = 16,
    OffsetEnd = 18,
    /** The Mint field contains the Rune ID of the rune to be minted in this transaction. */
    Mint = 20,
    /** The Pointer field contains the index of the output to which runes unallocated by edicts should be transferred. If the Pointer field is absent, unallocated runes are transferred to the first non-OP_RETURN output. */
    Pointer = 22,
    /** The Cenotaph field is unrecognized. */
    Cenotaph = 126,
    /** The Divisibility field, raised to the power of ten, is the number of subunits in a super unit of runes. */
    Divisibility = 1,
    /** The Spacers field is a bitfield of • spacers that should be displayed between the letters of the rune's name. Trailing spacers are ignored. */
    Spacers = 3,
    /** The Symbol field is the Unicode codepoint of the Rune's currency symbol,
     * which should be displayed after amounts of that rune. If a rune does not have a currency symbol,
     * the generic currency character ¤ should be used.
     * For example, if the Symbol is # and the divisibility is 2,
     * the amount of 1234 units should be displayed as 12.34 #.
     */
    Symbol = 5,
    /** The Nop field is unrecognized. */
    Nop = 127
}
export declare enum Flaw {
    EdictOutput = 0,
    EdictRuneId = 1,
    InvalidScript = 2,
    Opcode = 3,
    SupplyOverflow = 4,
    TrailingIntegers = 5,
    TruncatedField = 6,
    UnrecognizedEvenTag = 7,
    UnrecognizedFlag = 8,
    Varint = 9
}
export declare class Range {
    start: Option<number>;
    end: Option<number>;
    constructor(start: Option<number>, end: Option<number>);
}
export declare class Terms {
    amount: number;
    cap: number;
    height: Range;
    offset: Range;
    constructor(amount: number, cap: number, height: Range, offset: Range);
}
export declare class Rune {
    value: bigint;
    constructor(value: bigint);
    get name(): string;
    static toName(s: bigint): string;
    static fromName(name: string): Rune;
    toString(): string;
}
export declare class Etching {
    divisibility: Option<number>;
    premine: Option<number>;
    rune: Option<Rune>;
    spacers: Option<number>;
    symbol: Option<string>;
    terms: Option<Terms>;
    turbo: boolean;
    static readonly MAX_DIVISIBILITY: number;
    static readonly MAX_SPACERS: number;
    constructor(divisibility: Option<number>, premine: Option<number>, rune: Option<Rune>, spacers: Option<number>, symbol: Option<string>, terms: Option<Terms>, turbo: boolean);
}
export interface EtchJSON {
    name: string;
    divisibility?: number;
    premine?: number;
    symbol?: string;
    amount: number;
    cap: number;
    startHeight?: number;
    endHeight?: number;
    startOffset?: number;
    endOffset?: number;
    pointer?: number;
}
export interface MintJSON {
    block: number;
    txIdx: number;
    pointer?: number;
}
export declare class Runestone {
    edicts: Array<Edict>;
    etching: Option<Etching>;
    mint: Option<RuneId>;
    pointer: Option<number>;
    static readonly MAGIC_NUMBER: number;
    constructor(edicts: Array<Edict>, etching: Option<Etching>, mint: Option<RuneId>, pointer: Option<number>);
    static create(json: EtchJSON | MintJSON, type?: 'etch' | 'mint' | 'transfer'): Runestone;
    static decipher(rawTx: string): Option<Runestone>;
    encipher(): Buffer;
    static payload(tx: Transaction): Option<number[]>;
    static integers(payload: number[]): Option<bigint[]>;
    toMessage(): Message;
}
export declare class Message {
    fields: Map<number, Array<bigint>>;
    edicts: Array<Edict>;
    flaws: number;
    constructor(fields?: Map<number, Array<bigint>>, edicts?: Array<Edict>, flaws?: number);
    static from_integers(tx: Transaction, integers: bigint[]): Message;
    addFieldVal(tag: number, val: bigint): void;
    addEdict(edict: Edict): void;
    toBuffer(): Buffer;
    getFlags(): number;
    hasFlags(flag: Flag): boolean;
    getMint(): Option<RuneId>;
    getEtching(): Option<Etching>;
    getDivisibility(): Option<number>;
    getPremine(): Option<number>;
    getRune(): Option<Rune>;
    getSpacers(): Option<number>;
    getHeightStart(): Option<number>;
    getHeightEnd(): Option<number>;
    getOffsetStart(): Option<number>;
    getOffsetEnd(): Option<number>;
    getCap(): Option<number>;
    getAmount(): Option<number>;
    getSymbol(): Option<string>;
    getTerms(): Option<Terms>;
    getPointer(): Option<number>;
}
export declare class EtchInscription {
    fields: Map<number, Buffer>;
    data: Buffer;
    static Tag: {
        CONTENT_TYPE: number;
        POINTER: number;
        PARENT: number;
        METADATA: number;
        METAPROTOCOL: number;
        CONTENT_ENCODING: number;
        DELEGATE: number;
        RUNE: number;
    };
    constructor(fields?: Map<number, Buffer>, data?: Buffer);
    setContent(contentType: string, data: Buffer): void;
    setRune(rune: string): void;
    setField(field: number, val: Buffer): void;
    static decipher(rawTx: string, inputIdx: number): EtchInscription;
    encipher(): Buffer;
}
