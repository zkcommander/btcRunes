var i=function($){if($<0n)throw new Error("Value must be positive");if($>F)throw new Error(`Can't encode value more than ${F}`);const B=Buffer.alloc(v);let H=0;while($>>7n>0)B[H]=Number($&0b1111_1111n|0b1000_0000n),$>>=7n,H+=1;return B[H]=Number($),B.subarray(0,H+1)},Y=function($){if($.length>v||$.length===v&&$[$.length-1]>3)throw new Error(`Can't decode value more than ${F}, buffer overflow`);let B=BigInt(0);for(let H=0;H<$.length;H+=1){const N=$[H]&127;B=B|BigInt(N)<<7n*BigInt(H)}if(B<0n)throw new Error("Value is minus, something wrong");return B},o=0xffn,m=0xffffn,p=0xffff_ffffn,b=0xffff_ffff_ffff_ffffn,F=0xffff_ffff_ffff_ffff_ffff_ffff_ffff_ffffn,v=19;class D{n;maxNumber;constructor($,B){this.n=$,this.maxNumber=B,this.baseValidation()}baseValidation(){if(this.n<0n)throw new Error("Value must be positive");if(this.n>this.maxNumber)throw new Error(`Value must be less than ${this.maxNumber}`)}get MAX(){return this.maxNumber}toVaruint(){return i(this.n)}toString(){return this.n.toString()}toJSON(){return this.n.toString()}toValue(){return this.n}}class A extends D{constructor($){super($,o)}static fromString($){return new A(BigInt($))}static fromNumber($){return new A(BigInt($))}static fromVaruint($){return new A(Y($))}}class J extends D{constructor($){super($,m)}static fromString($){return new J(BigInt($))}static fromNumber($){return new J(BigInt($))}static fromVaruint($){return new J(Y($))}}class _ extends D{constructor($){super($,p)}static fromString($){return new _(BigInt($))}static fromNumber($){return new _(BigInt($))}static fromVaruint($){return new _(Y($))}}class O extends D{constructor($){super($,b)}static fromString($){return new O(BigInt($))}static fromVaruint($){return new O(Y($))}}class W extends D{constructor($){super($,F)}static fromString($){return new W(BigInt($))}static fromVaruint($){return new W(Y($))}}var q;(function(N){N[N["Etching"]=0]="Etching";N[N["Terms"]=1]="Terms";N[N["Cenotaph"]=127]="Cenotaph"})(q||(q={}));class U{flag;constructor($){this.flag=$}set($){const B=1n<<BigInt($);this.flag=new A(this.flag.toValue()|B)}hasFlag($){const B=1n<<BigInt($);return(this.flag.toValue()&B)!==0n}toValue(){return this.flag}}class z{rune;constructor($){this.rune=$}static fromString($){let B=0n;for(let H=0;H<$.length;H+=1){const N=$.charAt(H);if(H>0)B+=1n;if(B*=26n,N>="A"&&N<="Z")B+=BigInt(N.charCodeAt(0)-"A".charCodeAt(0));else throw new Error(`Invalid character in rune name: ${N}`)}return new z(new W(B))}commitBuffer(){let $=this.rune.toValue();const B=[];while($>>8n>0)B.push(Number($&0b11111111n)),$>>=8n;return B.push(Number($)),Buffer.from(B)}toString(){let $=this.rune.toValue();$+=1n;let B="";while($>0n)B+="ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Number(($-1n)%26n)],$=($-1n)/26n;return B.split("").reverse().join("")}toJSON(){return this.toString()}}class Q{block;tx;constructor($,B){this.block=$,this.tx=B}delta($){const B=$.block.toValue()-this.block.toValue();let H=$.tx.toValue();if(B===0n)H-=this.tx.toValue();return new Q(new O(B),new _(H))}next($){const B=this.block.toValue()+$.block.toValue(),H=$.block.toValue()===0n?this.tx.toValue()+$.tx.toValue():$.tx.toValue();return new Q(new O(B),new _(H))}toJSON(){return{block:this.block.toString(),tx:this.tx.toString()}}}var G;(function(L){L[L["Body"]=0]="Body";L[L["Flags"]=2]="Flags";L[L["Rune"]=4]="Rune";L[L["Premine"]=6]="Premine";L[L["Cap"]=8]="Cap";L[L["Amount"]=10]="Amount";L[L["HeightStart"]=12]="HeightStart";L[L["HeightEnd"]=14]="HeightEnd";L[L["OffsetStart"]=16]="OffsetStart";L[L["OffsetEnd"]=18]="OffsetEnd";L[L["Mint"]=20]="Mint";L[L["Pointer"]=22]="Pointer";L[L["Cenotaph"]=126]="Cenotaph";L[L["Divisibility"]=1]="Divisibility";L[L["Spacers"]=3]="Spacers";L[L["Symbol"]=5]="Symbol";L[L["Nop"]=127]="Nop"})(G||(G={}));var M;(function(Z){Z[Z["U8"]=0]="U8";Z[Z["U16"]=1]="U16";Z[Z["U32"]=2]="U32";Z[Z["U64"]=3]="U64";Z[Z["U128"]=4]="U128"})(M||(M={}));class j{payloads=[];edicts=[];tagMap=new Map;constructor($){if(!$)return;this.payloads.push(...$)}decode(){const $=[];let B=-1;for(let H=0;H<this.payloads.length;H+=1){const N=this.payloads[H];if((N&128)===0){if(B!==-1)$.push(Y(Buffer.from(this.payloads.slice(B,H+1)))),B=-1;else $.push(BigInt(N));continue}if(B===-1)B=H}for(let H=0;H<$.length/2;H++){const N=H*2,X=$[N];if(Number(X)===G.Body){this.edicts=$.slice(N+1);break}const Z=H*2+1;if(Z>=$.length)throw new Error("Buffer length is not valid");const C=$[Z],E=this.tagMap.get(Number(X));if(E){this.tagMap.set(Number(X),E.concat(C));continue}this.tagMap.set(Number(X),[C])}}getValue($,B,H=0){const N=this.tagMap.get($);if(!N)return;const X=N[H];switch(B){case M.U8:return new A(X);case M.U16:return new J(X);case M.U32:return new _(X);case M.U64:return new O(X);case M.U128:return new W(X)}}pushVaruint($){const B=$.toVaruint();for(let H=0;H<B.length;H+=1)this.payloads.push(B[H])}encodeTagPush($,...B){for(let H=0;H<B.length;H++){const N=B[H];if(N===void 0)continue;this.payloads.push($),this.pushVaruint(N)}}encodeMultiplePush($){if(!$.length)return;for(let B=0;B<$.length;B++){const H=$[B];if(H===void 0)continue;this.pushVaruint(H)}}toBuffer(){return Buffer.from(this.payloads)}}class k{symbol;constructor($){this.symbol=$}static fromString($){if($.length!==1)throw new Error("Symbol must be 1 character");return new k(new A(BigInt(Buffer.from($,"utf8")[0])))}toString(){return Buffer.from([Number(this.symbol.toValue())]).toString("utf8")}toJSON(){return this.toString()}}class P{edicts;etching;mint;pointer;constructor($){this.edicts=$.edicts,this.etching=$.etching,this.mint=$.mint,this.pointer=$.pointer}static dechiper($){const B=new j($);B.decode();let H;const N=B.getValue(G.Flags,M.U8);if(N){const S=new U(N);if(S.hasFlag(q.Etching))H={divisibility:B.getValue(G.Divisibility,M.U8),premine:B.getValue(G.Premine,M.U128),rune:new z(B.getValue(G.Rune,M.U128)),spacers:B.getValue(G.Spacers,M.U32),symbol:B.getValue(G.Symbol,M.U8)?new k(B.getValue(G.Symbol,M.U8)):void 0,terms:S.hasFlag(q.Terms)?{amount:B.getValue(G.Amount,M.U128),cap:B.getValue(G.Cap,M.U128),height:{start:B.getValue(G.HeightStart,M.U64),end:B.getValue(G.HeightEnd,M.U64)},offset:{start:B.getValue(G.OffsetStart,M.U64),end:B.getValue(G.OffsetEnd,M.U64)}}:void 0}}const X=B.getValue(G.Pointer,M.U32),Z=B.getValue(G.Mint,M.U64,0),C=B.getValue(G.Mint,M.U64,1);let E;if(Z&&C)E=new Q(Z,C);const x=[],K=B.edicts;if(K.length){if(K.length&&K.length%4)throw new Error("Edict data length is not valid");let S=new Q(new O(0n),new _(0n));for(let f=0;f<K.length/4;f++){const h=f*4,R=S.next(new Q(new O(K[h]),new _(K[h+1]))),I=K[h+2],c=K[h+3];x.push({id:R,amount:new W(I),output:new _(c)}),S=R}}return new P({etching:H,edicts:x,pointer:X,mint:E})}enchiper(){const $=new j;if(this.etching!==void 0){const B=this.etching,H=new U(new A(0n));if(H.set(q.Etching),B.terms)H.set(q.Terms);if($.encodeTagPush(G.Flags,H.toValue()),$.encodeTagPush(G.Rune,B.rune?.rune),$.encodeTagPush(G.Divisibility,B.divisibility),$.encodeTagPush(G.Spacers,B.spacers),$.encodeTagPush(G.Premine,B.premine),$.encodeTagPush(G.Symbol,B.symbol?.symbol),B.terms){const N=B.terms;if($.encodeTagPush(G.Amount,N.amount),$.encodeTagPush(G.Cap,N.cap),N.height)$.encodeTagPush(G.HeightStart,N.height.start),$.encodeTagPush(G.HeightEnd,N.height.end);if(N.offset)$.encodeTagPush(G.OffsetStart,N.offset.start),$.encodeTagPush(G.OffsetEnd,N.offset.end)}}if($.encodeTagPush(G.Pointer,this.pointer),this.mint!==void 0)$.encodeTagPush(G.Mint,this.mint.block,this.mint.tx);if(this.edicts.length){$.payloads.push(G.Body),this.edicts.sort((H,N)=>{return Number(H.id.block.toValue()-N.id.block.toValue()||H.id.tx.toValue()-N.id.tx.toValue())});let B=new Q(new O(0n),new _(0n));for(let H=0;H<this.edicts.length;H+=1){const N=this.edicts[H],X=B.delta(N.id);$.encodeMultiplePush([X.block,X.tx,N.amount,N.output]),B=N.id}}return $.toBuffer()}}class V{rune;spacers;constructor($,B){this.rune=$,this.spacers=B}static fromString($){let B="",H=0;for(let N=0;N<$.length;N++){const X=$[N];if(/[A-Z]/.test(X))B+=X;else if(X==="."||X==="\u2022"){const Z=1<<B.length-1;if((H&Z)!==0)throw new Error("Double spacer");H|=Z}else throw new Error("Invalid spacer character")}if(32-Math.clz32(H)>=B.length)throw new Error("Trailing spacer");return new V(z.fromString(B),new _(BigInt(H)))}toString(){const $=this.rune.toString();let B="";for(let H=0;H<$.length;H+=1){const N=$[H];if(B+=N,this.spacers.toValue()&1n<<BigInt(H))B+="\u2022"}return B}toJSON(){return this.toString()}}export{M as ValueType,j as TagPayload,G as Tag,k as Symbol,V as SpacedRune,P as Runestone,Q as RuneId,z as Rune,q as FlagEnum,U as Flag};
